<?php

return [
    'balance_transfer.description' => 'The params to make a balance transfer.',
    'burn_params.description' => 'Defines the configuration for the token burn operation, including the token to be burned, the amount to reduce from circulation, and additional settings for permanent removal from the blockchain.',
    'burn_params.field.removeTokenStorage' => 'If set to `true`, the token will be removed from the blockchain if its circulating supply is fully burned and it has no attributes. Removing the token storage retrieves the ENJ reserved for the token. Defaults to `false`.',
    'collection_mutation.description' => 'Defines the changes to be applied to the collection, such as transferring ownership or updating default royalties.',
    'collection_mutation.field.owner' => 'The account to transfer the collection ownership to. If not provided, the current ownership remains unchanged. The new owner must approve the transfer once the transaction is complete. [Learn more](https://docs.enjin.io/docs/transfer-accept-collection).',
    'collection_mutation.field.royalty' => 'Specifies the default royalties to be applied in the marketplace for the collection.',
    'create_token_params.description' => "Defines the token's key properties, such as initial and max supply, metadata, and optional ENJ backing through infusion.",
    'create_token_params.field.attributes' => 'Set initial [metadata attributes](https://docs.enjin.io/docs/metadata-standard) for this token.',
    'create_token_params.field.cap' => 'Configures the maximum supply limit for the token. Defaults to no cap (infinite supply) unless specified. [Learn more](https://docs.enjin.io/docs/creating-tokens#option-a-using-the-enjin-dashboard).',
    'create_token_params.field.initialSupply' => 'The amount of supply to mint to the specified recipient. If the token has a supply cap, the total supply cannot exceed the cap.',
    'create_token_params.field.listingForbidden' => 'Forbids the token from being listed on the marketplace. Defaults to `false` (listings are allowed) and can be updated later.',
    'create_token_params.field.unitPrice' => '(DEPRECATED) The price of each token. The price cannot be zero and unitPrice * totalSupply must be greater than the token account deposit.',
    'create_token_params.field.accountDepositCount' => 'The number of accounts to reserve the token account storage deposit for. [Learn more](https://docs.enjin.io/docs/multitoken-pallet#token-account-deposit).',
    'create_token_params.field.infusion' => 'Specifies the amount of ENJ to infuse into each token unit, denoted in u128 (divided by 10^18). Defaults to no infusion. [Learn more](https://docs.enjin.io/docs/enj-infusion).',
    'create_token_params.field.anyoneCanInfuse' => 'Specifies if anyone can add ENJ infusion to the token. Defaults to `false`, restricting infusion to the token creator.',
    'create_token_params.field.metadata' => 'Configures the token as a "Currency Token," enabling support for fractional values and division into smaller units, similar to traditional currencies. [Learn more](https://docs.enjin.io/docs/creating-a-currency-token).',
    'encode_token_id.field.data' => 'The data to encode into a token ID.  Check the docs for the different encoder payload requirements.',
    'encode_token_id.field.type' => 'The encoding strategy to use to encode the token ID. Defaults to HASH.',
    'encodeable_token_id.description' => 'Specifies the token ID, supporting multiple encoding formats to identify tokens accurately. [Learn more](https://docs.enjin.io/docs/tokenid-structure).',
    'erc1155_encoder.description' => 'ERC1155 Style Token ID.',
    'market_policy.description' => 'The default marketplace royalties for all tokens in the collection. Royalties can still be set individually for each token.',
    'market_policy.field.royalty' => 'A default royalty percentage for all tokens in the collection. This can be overridden on a per-token basis.',
    'metadata.field.decimalCount' => 'The number of decimal places for the token. Defaults to 0, i.e. integer.',
    'metadata.field.name' => 'The token name.',
    'metadata.field.symbol' => 'The token symbol.',
    'mint_policy.description' => 'Minting restrictions for the collection or its tokens.',
    'mint_policy.field.forceCollapsingSupply' => 'Ensures all tokens in the collection are created with the "Collapsing Supply" cap type, which limits the total number of token balance that can ever be minted. Burned tokens reduce the available supply permanently and cannot be re-minted.',
    'mint_policy.field.forceSingleMint' => '(DEPRECATED) Set whether the tokens in this collection will be minted as SingleMint types. This would indicate the tokens in this collection are NFTs.',
    'mint_recipient.description' => 'Define the recipient account and include either `createParams` to configure new token creation or `mintParams` to specify existing tokens and amounts to mint. Only one of `createParams` or `mintParams` should be provided per entry.',
    'mint_recipient.field.account' => 'The recipient account of the token.',
    'mint_recipient.field.createParams' => "Use to create a new token. Defines the token's key properties, such as initial and max supply, metadata, and optional ENJ backing through infusion.",
    'mint_recipient.field.mintTokenParams' => 'Use to mint additional supply for existing token by specifiying the token ID, and the amount to mint.',
    'mint_token_params.description' => 'The token id, and the amount to mint.',
    'mint_token_params.field.unitPrice' => '(DEPRECATED) Leave as null if you want to keep the same unitPrice. You can also put a value if you want to change the unitPrice. Please note you can only increase it and a deposit to the difference of every token previously minted will also be needed.',
    'multi_token_id.description' => 'The unique identifier for a token. Composed using a collection ID and a token ID.',
    'multi_token_id.field.collectionId' => 'The collection id of a multi token.',
    'multi_token_id.field.tokenId' => 'The token ID of a multi token.',
    'mutation_royalty.description' => 'Defines the configuration for marketplace royalties applied to the token.',
    'mutation_royalty.field.beneficiary' => 'Specifies the account address that will receive the royalties.',
    'mutation_royalty.field.isCurrency' => 'Indicates whether the token can be used as a royalty token. This feature is a placeholder for potential future on-chain implementation and is not currently active.',
    'mutation_royalty.field.percentage' => 'Specifies the percentage of the sale value that the beneficiary will receive as royalties.',
    'operator_transfer_params.description' => 'Configures the details of the token transfer, including the operator involved.',
    'operator_transfer_params.field.source' => 'The account from which the tokens will be sent. Must be approved beforehand; see the [transfer approvals documentation](https://docs.enjin.io/docs/multitoken-pallet#transfer-approvals) for more details.',
    'simple_transfer_params.description' => 'The token id, and the amount to transfer.',
    'token_data.description' => 'Data for a token on the Ethereum network.',
    'token_freeze_state.description' => 'Specifies the freeze configuration for the token, determining if and how it can be frozen. By default, the token is not frozen. [Learn more](https://docs.enjin.io/docs/freezing-thawing).',
    'token_id_encoder.erc1155.description' => 'Creates an integer representation from an ERC1155 style token input.',
    'token_id_encoder.erc1155.index.description' => 'A 64bit integer index.  This will be converted to hex and concatenated with the tokenId to make the final unique NFT id.  Defaults to 0 is not supplied.',
    'token_id_encoder.erc1155.token_id.description' => 'A 16 character hex formatted ERC1155 style token id, e.g. 0x1080000000000123.',
    'token_id_encoder.hash.description' => 'Hashes an arbitrary object into an integer.',
    'token_id_encoder.integer.description' => 'A 128bit unsigned integer, the native format for Substrate.',
    'token_id_encoder.string_id.description' => 'Converts a string into a hex value, then converts that to an integer.  This encoding is reversible.',
    'token_market_behavior.description' => 'Configures marketplace behavior, such as setting marketplace royalties or defining the token as a royalty token. By default, no royalties are applied.',
    'token_mint_cap.description' => "The token's cap model type and it's max amount.",
    'token_mint_cap.field.amount' => "Defines the cap amount. In the 'Supply' model, this represents the maximum number of tokens that can be in circulation. In the 'Collapsing' model, it specifies the maximum number of tokens that can be minted.",
    'token_mint_cap.field.type' => "The supply model type for this token. Defaults to no cap (infinite supply) unless specified. Supports supply models such as 'Supply' for a fixed limit or 'Collapsing' for a dynamic reduction model.",
    'token_mutation.description' => 'Defines the changes to be applied to the token, including the token\'s default royalties for the marketplace, forbidding marketplace listings, updating the token\'s infusion permissions, and the token name.',
    'token_mutation.field.anyoneCanInfuse' => 'Change the anyoneCanInfuse state, which specifies if anyone can add ENJ infusion to the token. If not provided, the anyoneCanInfuse property will not be changed.',
    'token_mutation.field.behavior' => 'Change marketplace behavior, such as the marketplace royalties or if the token as a royalty token. If not provided, the behavior will not be changed.',
    'token_mutation.field.listingForbidden' => 'Change the listingForbidden state, which forbids the token from being listed on the marketplace. If not provided, the listingForbidden property will not be changed.',
    'token_mutation.field.name' => 'Change the token name. If not provided, the name will not be changed.',
    'transfer_recipient.description' => 'Defines the configuration for a batch transfer, specifying the recipient account and transfer parameters. You must provide either `simpleParams` to send tokens directly from the sender\'s account or `operatorParams` to transfer tokens from an operator account, which requires [prior approval](https://docs.enjin.io/docs/multitoken-pallet#transfer-approvals) from the source wallet owner.',
    'transfer_recipient.field.operatorTransferParams' => 'The params for an operator transfer.',
    'transfer_recipient.field.simpleTransferParams' => 'The params for a simple transfer.',
    'transfer_recipient.field.transferBalanceParams' => 'The params for a balance transfer.',
    'account_rule.description' => 'Defines criteria that accounts must meet to be added as Fuel Tank User Accounts. These rules are validated during the creation of Tank User Accounts, ensuring only eligible accounts are added based on the specified criteria. [Learn more](https://docs.enjin.io/docs/fuel-tank-pallet#account-rules).',
    'account_rule.field.whitelistedCallers' => 'Defines a list of accounts (as an array of strings) that are allowed to be added as Fuel Tank User Accounts. Only accounts included in this whitelist can be added.',
    'account_rule.field.requireToken' => 'Specifies that only accounts holding a specific multiToken are eligible to be added as Fuel Tank User Accounts.',
    'dispatch_rule.description' => 'Specifies rule sets that are validated when dispatching a transaction subsidized by the Fuel Tank. Each rule set can contain multiple individual rules that control access and permissions, ensuring the dispatch call adheres to the defined criteria.\n**Note:**: A fuel tank must have at least one rule set that includes at least one rule for it to be operational.\n[Learn more](https://docs.enjin.io/docs/fuel-tank-pallet#dispatch-rules).',
    'dispatch_rule.field.maxFuelBurnPerTransaction' => 'Limits the maximum amount of fuel that can be consumed in a single transaction. Dispatches exceeding this limit will fail',
    'dispatch_rule.field.requireToken' => 'Specifies that only accounts holding a specific multiToken are eligible to dispatch transactions using this rule set.',
    'dispatch_rule.field.tankFuelBudget' => 'Sets the total fuel allocated to the rule set. Once the tank\'s fuel budget is depleted, all dispatches using this rule set will fail.',
    'dispatch_rule.field.userFuelBudget' => 'Defines the total amount of fuel allocated to a specific tank user account. Dispatches from the user will fail once their fuel budget is exhausted.',
    'dispatch_rule.field.whitelistedCallers' => 'Defines a list of accounts (as an array of strings) that are allowed to dispatch transactions. Only accounts included in this whitelist can dispatch using this rule set.',
    'dispatch_rule.field.whitelistedCollections' => 'Requires the caller to hold any token from the specified collection. Only accounts owning a token from the collection can dispatch using this rule set.',
    'fuel_budget.description' => 'Specifies the total amount of fuel allocated. Once the allocated fuel is exhausted, dispatches associated with the budget will fail.',
    'fuel_budget.field.amount' => 'The total fuel allocated for the specified budget.',
    'fuel_budget.field.resetPeriod' => 'The recurring period, measured in blocks, after which the allocated fuel automatically resets to its full amount. To effectively disable resets, set this value to the maximum (4,294,967,295).',
    'require_token.description' => 'The rule for requiring a specific token.',
    'require_token.field.collectionId' => 'The collection chain ID.',
    'require_token.field.tokenId' => 'The token chain ID.',
    'fuel_tank_mutation.description' => 'Specifies the fields of the fuel tank to be modified. These include options for updating the [User Account Management](https://docs.enjin.io/docs/using-fuel-tanks#user-account-management), [Coverage Policy](https://docs.enjin.io/docs/using-fuel-tanks#coverage-policy), and [Account Rules](https://docs.enjin.io/docs/using-fuel-tanks#account-rules).',
    'dispatch.description' => 'The dispatch call.',
    'dispatch.field.query' => "The GraphQL query. It's required to query the 'id' and 'encodedData' from the result.",
    'dispatch.field.variables' => 'The GraphQL query variables.',
    'permitted_extrinsics.description' => 'Specifies a list of allowed extrinsic functions that can be executed using this rule set. Only these functions are permitted for dispatch.',
    'require_signature.description' => 'Requires each call to include a signature from the specified account. The account provided in this argument must sign the call for it to be accepted by the fuel tank. This rule is ideal for scenarios where the `requireSignature` is set to the daemon account, and dispatches are broadcasted from [managed wallets](https://docs.enjin.io/docs/using-managed-wallets). It enables a fuel tank to be restricted to managed wallets without explicitly storing each wallet address, saving storage fees and allowing dynamic whitelisting of dispatch accounts. [Learn more](https://docs.enjin.io/docs/fuel-tank-pallet#require-signature).',
    'require_signature.field.signature' => 'The wallet which we will require to sign the transaction.',
    'dispatch_settings.description' => 'The dispatch settings.',
    'dispatch_settings.field.paysRemainingFee' => 'The flag to pay the remaining fee.',
    'dispatch_settings.field.signature' => 'The expirable signature to use for this dispatch.',
    'expirable_signature.description' => 'The expirable signature.',
    'expirable_signature.field.signature' => 'The signature.',
    'expirable_signature.field.expiryBlock' => 'The expiry block.',
];
